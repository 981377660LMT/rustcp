//Generated by https://github.com/taodaling/scheduler
//Timestamp: 2022-01-03 16:37:02
pub mod macros {

    #[cfg(feature = "local-build")]
    macro_rules! should {
    ($($e: expr),*) => {
        $(
            assert!($e);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! should_eq {
    ($($a: expr, $b: expr);*) => {
        $(
            assert_eq!($a, $b);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should_eq {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug {
        ($e: expr) => {
            std::convert::identity($e)
        };
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug_discard {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug_discard {
        ($e: expr) => {};
    }

    macro_rules! input {

    ($fi:ident, $var:ident $( : $t:ty)?, $($arg:tt)*) => {
        let mut $var $(: $t)? = $fi.read();
        input!($fi, $($arg)*)
    };

    ($fi: ident $(,)?) => {
    };
}

    macro_rules! MergerImpl {
        ($name: ident, $A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            struct $name;
            impl Merger<$A, $B, $C> for $name {
                fn merge($a: $A, $b: $B) -> $C {
                    $body
                }
            }
        };
    }

    macro_rules! AddImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Add<$B> for $A {
                type Output = $C;

                fn add(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }

    macro_rules! SubImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Mul<$B> for $A {
                type Output = $C;

                fn sub(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }

    macro_rules! DivImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Mul<$B> for $A {
                type Output = $C;

                fn div(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }

    macro_rules! MulImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Sub<$B> for $A {
                type Output = $C;

                fn mul(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }

    pub(crate) use debug;
    pub(crate) use debug_discard;
    pub(crate) use input;
    pub(crate) use should;
    pub(crate) use should_eq;
    pub(crate) use AddImpl;
    pub(crate) use DivImpl;
    pub(crate) use MergerImpl;
    pub(crate) use MulImpl;
    pub(crate) use SubImpl;
}
pub mod num_number {
    use std::fmt::Debug;
    use std::fmt::Display;
    use std::ops::Add;
    use std::ops::AddAssign;
    use std::ops::Div;
    use std::ops::DivAssign;
    use std::ops::Mul;
    use std::ops::MulAssign;
    use std::ops::Sub;
    use std::ops::SubAssign;
    use std::str::FromStr;

    pub trait FromNumber {
        fn from(num: impl Number) -> Self;
    }

    pub trait Number:
        Copy
        + Add<Output = Self>
        + Sub<Output = Self>
        + Mul<Output = Self>
        + Div<Output = Self>
        + PartialEq
        + PartialOrd
        + Display
        + Debug
        + FromStr
        + AddAssign
        + SubAssign
        + MulAssign
        + DivAssign
        + FromNumber
    {
        const MAX: Self;
        const MIN: Self;
        const ZERO: Self;
        const ONE: Self;

        type HighPrecisionType: Number;
        type SignedType: Number;

        fn upgrade(&self) -> Self::HighPrecisionType {
            FromNumber::from(*self)
        }

        fn sign(&self) -> i8 {
            if self.is_negative() {
                -1
            } else if self.is_positive() {
                1
            } else {
                0
            }
        }
        fn negative(&self) -> Self {
            Self::ZERO - *self
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
        fn is_positive(&self) -> bool {
            *self > Self::ZERO
        }
        fn is_non_negative(&self) -> bool {
            *self >= Self::ZERO
        }
        fn is_non_positive(&self) -> bool {
            *self <= Self::ZERO
        }
        fn absolute(&self) -> Self {
            if self.is_negative() {
                self.negative()
            } else {
                *self
            }
        }
        fn as_signed(&self) -> Self::SignedType;
        fn as_i8(&self) -> i8;
        fn as_u8(&self) -> u8;
        fn as_i16(&self) -> i16;
        fn as_u16(&self) -> u16;
        fn as_i32(&self) -> i32;
        fn as_u32(&self) -> u32;
        fn as_i64(&self) -> i64;
        fn as_u64(&self) -> u64;
        fn as_i128(&self) -> i128;
        fn as_u128(&self) -> u128;
        fn as_isize(&self) -> isize;
        fn as_usize(&self) -> usize;
        fn as_f32(&self) -> f32;
        fn as_f64(&self) -> f64;
    }

    macro_rules! Generator {
        ($t: ty, $as_method: ident, $H: ident) => {
            Generator!($t, $t, $as_method, $H);
        };
        ($t: ty, $s: ty, $as_method: ident, $H: ident) => {
            impl FromNumber for $t {
                #[inline(always)]
                fn from(num: impl Number) -> Self {
                    num.$as_method()
                }
            }

            impl Number for $t {
                type SignedType = $s;
                type HighPrecisionType = $H;
                const MAX: Self = <$t>::MAX;
                const MIN: Self = <$t>::MIN;
                const ZERO: Self = 0 as Self;
                const ONE: Self = 1 as Self;
                #[inline(always)]
                fn absolute(&self) -> Self {
                    if self.is_negative() {
                        self.negative()
                    } else {
                        *self
                    }
                }
                #[inline(always)]
                fn as_signed(&self) -> Self::SignedType {
                    *self as Self::SignedType
                }

                fn as_i8(&self) -> i8 {
                    *self as i8
                }
                fn as_u8(&self) -> u8 {
                    *self as u8
                }
                fn as_i16(&self) -> i16 {
                    *self as i16
                }
                fn as_u16(&self) -> u16 {
                    *self as u16
                }
                fn as_i32(&self) -> i32 {
                    *self as i32
                }
                fn as_u32(&self) -> u32 {
                    *self as u32
                }
                fn as_i64(&self) -> i64 {
                    *self as i64
                }
                fn as_u64(&self) -> u64 {
                    *self as u64
                }
                fn as_i128(&self) -> i128 {
                    *self as i128
                }
                fn as_u128(&self) -> u128 {
                    *self as u128
                }
                fn as_isize(&self) -> isize {
                    *self as isize
                }
                fn as_usize(&self) -> usize {
                    *self as usize
                }
                fn as_f32(&self) -> f32 {
                    *self as f32
                }
                fn as_f64(&self) -> f64 {
                    *self as f64
                }
            }
        };
    }

    Generator!(usize, as_usize, u64);
    Generator!(isize, as_isize, i64);

    Generator!(i8, as_i8, i16);
    Generator!(i16, as_i16, i32);
    Generator!(i32, as_i32, i64);
    Generator!(i64, as_i64, i128);
    Generator!(i128, as_i128, i128);

    Generator!(u8, i8, as_u8, u16);
    Generator!(u16, i16, as_u16, u32);
    Generator!(u32, i32, as_u32, u64);
    Generator!(u64, i64, as_u64, u128);
    Generator!(u128, i128, as_u128, u128);

    Generator!(f32, as_f32, f64);
    Generator!(f64, as_f64, f64);
}
pub mod num_concrete {
    use crate::num_number::Number;

    pub trait Concrete: Number + Eq + Ord {}

    macro_rules! Concrete {
        ($name: ident) => {
            impl Concrete for $name {}
        };
    }

    Concrete!(i8);
    Concrete!(u8);
    Concrete!(i16);
    Concrete!(u16);
    Concrete!(i32);
    Concrete!(u32);
    Concrete!(i64);
    Concrete!(u64);
    Concrete!(i128);
    Concrete!(u128);
    Concrete!(isize);
    Concrete!(usize);
}
pub mod num_integer {
    use crate::macros::should;
    use crate::num_concrete::Concrete;
    use crate::num_number::FromNumber;
    use crate::num_number::Number;
    use std::hash::Hash;
    use std::ops::BitAnd;
    use std::ops::BitOr;
    use std::ops::BitXor;
    use std::ops::Not;
    use std::ops::Rem;
    use std::ops::Shl;
    use std::ops::Shr;

    pub trait Integer:
        Concrete
        + Rem<Output = Self>
        + Shl<Output = Self>
        + Shr<Output = Self>
        + BitAnd<Output = Self>
        + BitOr<Output = Self>
        + BitXor<Output = Self>
        + Not<Output = Self>
        + Ord
        + std::ops::ShrAssign
        + std::ops::ShlAssign
        + Hash
    {
        type UnsignedIntegerType: Integer;
        type SignedIntegerType: Integer;
        const BITS: i32;

        fn as_unsigned(&self) -> Self::UnsignedIntegerType {
            FromNumber::from(*self)
        }

        fn bit_count(&self) -> Self;
        fn higest_set_bit_offset(&self) -> i32;
        fn lowest_set_bit(&self) -> Self;
        fn higest_one_bit(&self) -> Self;
        fn count_leading_zero(&self) -> i32;
        fn count_trailing_zero(&self) -> i32;
        #[inline]
        fn modular(a: Self, m: Self) -> Self {
            let res = a % m;
            if res.is_negative() {
                res + m
            } else {
                res
            }
        }
        #[inline]
        fn sub_mod(a: Self, b: Self, m: Self) -> Self {
            if a < b {
                a - b + m
            } else {
                a - b
            }
        }
        #[inline]
        fn add_mod(a: Self, b: Self, m: Self) -> Self {
            let res = a + b;
            if res < Self::ZERO || res >= m {
                res - m
            } else {
                res
            }
        }
        fn mul_mod(a: Self, b: Self, m: Self) -> Self;
        fn pow_mod(a: Self, n: Self, m: Self) -> Self {
            if n == Self::ZERO {
                Self::ONE
            } else {
                let ans = Self::pow_mod(a, n >> Self::ONE, m);
                let ans = Self::mul_mod(ans, ans, m);
                if (n & Self::ONE) == Self::ONE {
                    Self::mul_mod(ans, a, m)
                } else {
                    ans
                }
            }
        }
        fn pow(a: Self, mut n: u32) -> Self {
            let mut ans = a;
            while n > 1 {
                n -= 1u32;
                ans = ans * a;
            }
            ans
        }
        fn average_floor(a: Self, b: Self) -> Self {
            (a & b) + ((a ^ b) >> FromNumber::from(1))
        }
        fn average_ceil(a: Self, b: Self) -> Self {
            (a | b) - ((a ^ b) >> FromNumber::from(1))
        }
        fn add_overflow(a: Self, b: Self) -> (Self, bool);
        fn add_or_default(a: Self, b: Self, def: Self) -> (Self, bool) {
            let mut res = Self::add_overflow(a, b);
            if res.1 {
                res.0 = def;
            }
            res
        }
        fn mul_or_default(a: Self, b: Self, def: Self) -> (Self, bool) {
            let mut res = Self::mul_overflow(a, b);
            if res.1 {
                res.0 = def;
            }
            res
        }
        fn bit_left_shift(&self, step: i32) -> Self {
            if step >= Self::BITS {
                Self::ZERO
            } else {
                *self << FromNumber::from(step)
            }
        }
        fn kth_bit(&self, k: usize) -> Self {
            should!(k < Self::BITS as usize);
            (*self >> FromNumber::from(k)) & Self::ONE
        }
        fn bit_signed_right_shift(&self, step: i32) -> Self;
        fn bit_unsigned_right_shift(&self, step: i32) -> Self;

        fn mul_overflow(a: Self, b: Self) -> (Self, bool);
        fn div_and_remainder(a: Self, b: Self) -> (Self, Self);
    }

    macro_rules! IntegerImpl {
        ($t: ty, $h: ty, $u: ty, $s: ty) => {
            impl Integer for $t {
                type UnsignedIntegerType = $u;
                type SignedIntegerType = $s;
                const BITS: i32 = <$t>::BITS as i32;
                #[inline(always)]
                fn count_trailing_zero(&self) -> i32 {
                    let x = 0;
                    if *self == <$t as Number>::ZERO {
                        <Self as Integer>::BITS
                    } else {
                        <Self as Integer>::BITS - 1 - self.lowest_set_bit().count_leading_zero()
                    }
                }
                #[inline(always)]
                fn bit_signed_right_shift(&self, step: i32) -> Self {
                    if step >= <Self as Integer>::BITS {
                        if self.is_negative() {
                            !Self::ZERO
                        } else {
                            Self::ZERO
                        }
                    } else {
                        ((*self as Self::SignedType) >> (step as Self::SignedType)) as Self
                    }
                }
                #[inline(always)]
                fn bit_unsigned_right_shift(&self, step: i32) -> Self {
                    if step >= <Self as Integer>::BITS {
                        Self::ZERO
                    } else {
                        ((*self as Self::UnsignedIntegerType)
                            >> (step as Self::UnsignedIntegerType)) as Self
                    }
                }
                #[inline(always)]
                fn mul_mod(a: Self, b: Self, m: Self) -> Self {
                    let mut res = ((a as Self::HighPrecisionType * b as Self::HighPrecisionType)
                        % (m as Self::HighPrecisionType)) as Self;
                    if res.is_negative() {
                        res = res + m;
                    }
                    res
                }
                #[inline(always)]
                fn add_overflow(a: Self, b: Self) -> (Self, bool) {
                    Self::overflowing_add(a, b)
                }
                #[inline(always)]
                fn mul_overflow(a: Self, b: Self) -> (Self, bool) {
                    Self::overflowing_mul(a, b)
                }
                #[inline(always)]
                fn bit_count(&self) -> Self {
                    self.count_ones() as $t
                }
                #[inline(always)]
                fn higest_set_bit_offset(&self) -> i32 {
                    (Self::BITS - 1 - self.leading_zeros()) as i32
                }
                #[inline(always)]
                fn lowest_set_bit(&self) -> Self {
                    *self & self.negative()
                }
                #[inline(always)]
                fn higest_one_bit(&self) -> Self {
                    if *self == Self::ZERO {
                        0
                    } else {
                        Self::ONE << <Self as FromNumber>::from(self.higest_set_bit_offset())
                    }
                }
                #[inline(always)]
                fn count_leading_zero(&self) -> i32 {
                    self.leading_zeros() as i32
                }
                #[inline(always)]
                fn div_and_remainder(a: Self, b: Self) -> (Self, Self) {
                    let d = a / b;
                    (d, a - d * b)
                }
            }
        };
    }

    IntegerImpl!(i8, i16, u8, i8);
    IntegerImpl!(u8, i16, u8, i8);
    IntegerImpl!(i16, i32, u16, i16);
    IntegerImpl!(u16, u32, u16, i16);
    IntegerImpl!(i32, i64, u32, i32);
    IntegerImpl!(u32, u64, u32, i32);
    IntegerImpl!(isize, isize, usize, isize);
    IntegerImpl!(usize, usize, usize, isize);
    IntegerImpl!(i64, i128, u64, i64);
    IntegerImpl!(u64, u128, u64, i64);
    IntegerImpl!(i128, i128, u128, i128);
    IntegerImpl!(u128, u128, u128, i128);
}
pub mod num_real {
    use crate::num_concrete::Concrete;
    use crate::num_number::FromNumber;
    use crate::num_number::Number;

    pub trait Real: Concrete {
        const PI: Self;
        const E: Self;

        fn average(a: Self, b: Self) -> Self {
            (a + b) / FromNumber::from(2)
        }
        fn sqrt(&self) -> Self;
        fn powf(&self, b: Self) -> Self;
        fn powi(&self, b: i32) -> Self;
        fn sin(&self) -> Self;
        fn cos(&self) -> Self;
        fn tan(&self) -> Self;
        fn asin(&self) -> Self;
        fn acos(&self) -> Self;
        fn atan(&self) -> Self;
        fn exp(&self) -> Self;
        fn ln(&self) -> Self;
        fn round(&self) -> Self;
    }
}
pub mod arithmetic {
    use crate::macros::should;
    use crate::num_integer::Integer;
    use crate::num_number::Number;
    use crate::num_real::Real;
    use std::fmt::Debug;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;

    pub trait CommutativeAdd: Add<Output = Self> + Copy + Debug {}
    pub trait AssociativeAdd: Add<Output = Self> + Copy + Debug {}
    pub trait IdentityAdd: Add<Output = Self> + Copy + Debug {
        fn zero() -> Self;
    }
    pub trait CommutativeMul: Mul<Output = Self> + Copy + Debug {}
    pub trait AssociativeMul: Mul<Output = Self> + Copy + Debug {}
    pub trait IdentityMul: Mul<Output = Self> + Copy + Debug {
        fn one() -> Self;
    }
    pub trait IdempotentAdd: CommutativeAdd + AssociativeAdd {}
    pub trait IdempotentMul: CommutativeMul + AssociativeMul {}
    pub trait IntegralMul: Mul<Output = Self> + Copy + Debug {}
    impl<T> IntegralMul for T where T: Div<Output = Self> + Mul<Output = Self> + Copy + Debug {}

    pub trait PreferDiv: Div<Output = Self> + Copy + Debug {
        fn div_ceil(a: Self, b: Self) -> Self {
            a / b
        }
        fn div_floor(a: Self, b: Self) -> Self {
            a / b
        }
    }

    impl PreferDiv for f32 {}
    impl PreferDiv for f64 {}
    impl<T: Integer> PreferDiv for T {
        fn div_ceil(a: Self, b: Self) -> Self {
            should!(b >= Self::ZERO);
            let res = a / b;
            if res * b > a {
                res - Self::ONE
            } else {
                res
            }
        }
        fn div_floor(a: Self, b: Self) -> Self {
            should!(b >= Self::ZERO);
            let res = a / b;
            if res * b < a {
                res + Self::ONE
            } else {
                res
            }
        }
    }

    pub trait LowerBound: PartialOrd {
        fn min_element() -> Self;
    }

    pub trait UpperBound: PartialOrd {
        fn max_element() -> Self;
    }

    macro_rules! AddTagImpl {
        ($t: ty, $zero: expr) => {
            impl CommutativeAdd for $t {}
            impl IdentityAdd for $t {
                fn zero() -> Self {
                    $zero
                }
            }
            impl AssociativeAdd for $t {}
            impl IdempotentAdd for $t {}
        };
    }

    macro_rules! MulTagImpl {
        ($t: ty, $one: expr) => {
            impl CommutativeMul for $t {}
            impl IdentityMul for $t {
                fn one() -> Self {
                    $one
                }
            }
            impl AssociativeMul for $t {}
            impl IdempotentMul for $t {}
        };
    }

    macro_rules! AddMulTagImpl {
        ($t: ty, $zero: expr, $one: expr) => {
            AddTagImpl!($t, $zero);
            MulTagImpl!($t, $one);
        };
    }

    impl<T> CommutativeAdd for T where T: Number {}
    impl<T> IdentityAdd for T
    where
        T: Number,
    {
        fn zero() -> Self {
            <T as Number>::ZERO
        }
    }
    impl<T> AssociativeAdd for T where T: Number {}
    impl<T> CommutativeMul for T where T: Number {}
    impl<T> IdentityMul for T
    where
        T: Number,
    {
        fn one() -> Self {
            <T as Number>::ONE
        }
    }
    impl<T> AssociativeMul for T where T: Number {}
    impl<T> LowerBound for T
    where
        T: Number,
    {
        fn min_element() -> Self {
            <T as Number>::MIN
        }
    }
    impl<T> UpperBound for T
    where
        T: Number,
    {
        fn max_element() -> Self {
            <T as Number>::MAX
        }
    }

    #[derive(Clone, Copy, Debug)]
    pub struct Nil;
    impl Mul for Nil {
        type Output = Nil;

        fn mul(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }
    impl Add for Nil {
        type Output = Nil;

        fn add(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }
    impl Sub for Nil {
        type Output = Nil;

        fn sub(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }

    impl Div for Nil {
        type Output = Nil;

        fn div(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }
    impl PartialEq for Nil {
        fn eq(&self, other: &Self) -> bool {
            true
        }
    }
    impl Eq for Nil {}
    impl PartialOrd for Nil {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            Some(std::cmp::Ordering::Equal)
        }
    }
    impl LowerBound for Nil {
        fn min_element() -> Self {
            Nil
        }
    }
    impl UpperBound for Nil {
        fn max_element() -> Self {
            Nil
        }
    }
    AddMulTagImpl!(Nil, Nil, Nil);
    pub(crate) use AddMulTagImpl;
    pub(crate) use AddTagImpl;
    pub(crate) use MulTagImpl;
}
pub mod algebraic_structure {
    use crate::arithmetic::*;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;

    pub trait Magma: Add<Output = Self> + Copy + Eq {}
    impl<T> Magma for T where T: Add<Output = Self> + Copy + Eq {}
    pub trait Semigroup: Magma + AssociativeAdd {}
    impl<T> Semigroup for T where T: Magma + AssociativeAdd {}
    pub trait Monoid: Semigroup + IdentityAdd {}
    impl<T> Monoid for T where T: Semigroup + IdentityAdd {}
    pub trait Group: Monoid + Sub<Output = Self> {}
    impl<T> Group for T where T: Monoid + Sub<Output = Self> {}
    pub trait AbelianGroup: Group + CommutativeAdd {}
    impl<T> AbelianGroup for T where T: Group + CommutativeAdd {}
    pub trait Ring: AbelianGroup + Mul<Output = Self> + IdentityMul {}
    impl<T> Ring for T where T: AbelianGroup + Mul<Output = Self> + IdentityMul {}
    pub trait CommutativeRing: Ring + CommutativeMul {}
    impl<T> CommutativeRing for T where T: Ring + CommutativeMul {}
    pub trait IntegralDomain: CommutativeRing + IntegralMul {}
    impl<T> IntegralDomain for T where T: CommutativeRing + IntegralMul {}
    pub trait Field: IntegralDomain + Div<Output = Self> {}
    impl<T> Field for T where T: IntegralDomain + Div<Output = Self> {}
}
pub mod binary_search {
    use crate::num_integer::Integer;
    use crate::num_number::FromNumber;
    use crate::num_real::Real;

    pub fn first_true<T>(mut l: T, mut r: T, f: impl Fn(&T) -> bool) -> Option<T>
    where
        T: Integer,
    {
        if l > r {
            return None;
        }
        while l < r {
            let m = T::average_floor(l, r);
            if f(&m) {
                r = m;
            } else {
                l = m + T::ONE;
            }
        }
        if f(&l) {
            Some(l)
        } else {
            None
        }
    }

    pub fn last_true<T>(mut l: T, mut r: T, f: impl Fn(&T) -> bool) -> Option<T>
    where
        T: Integer,
    {
        if l > r {
            return None;
        }
        while l < r {
            let m = T::average_ceil(l, r);
            if f(&m) {
                l = m;
            } else {
                r = m - T::ONE;
            }
        }
        if f(&l) {
            Some(l)
        } else {
            None
        }
    }

    pub fn first_true_float<T>(
        mut round: u8,
        mut l: T,
        mut r: T,
        f: impl Fn(&T) -> bool,
    ) -> Option<T>
    where
        T: Real,
    {
        if l > r {
            return None;
        }
        while round > 0 {
            round -= 1;
            let m = (l + r) / <T as FromNumber>::from(2);
            if f(&m) {
                r = m;
            } else {
                l = m;
            }
        }
        if f(&l) {
            Some(l)
        } else {
            None
        }
    }

    pub fn last_true_real<T>(mut round: u8, mut l: T, mut r: T, f: impl Fn(&T) -> bool) -> Option<T>
    where
        T: Real,
    {
        if l > r {
            return None;
        }
        while round > 0 {
            round -= 1;
            let m = (l + r) / <T as FromNumber>::from(2);
            if f(&m) {
                l = m;
            } else {
                r = m;
            }
        }
        if f(&l) {
            Some(l)
        } else {
            None
        }
    }
}
pub mod num_gcd {
    use crate::macros::should;
    use crate::macros::should_eq;
    use crate::num_integer::Integer;
    use crate::num_number::FromNumber;
    use crate::num_number::Number;

    pub fn gcd<T>(a: T, b: T) -> T
    where
        T: Integer,
    {
        should! {a.is_non_negative(), b.is_non_negative()};
        let mut s = (a, b);
        while s.1 > T::ZERO {
            s = (s.1, s.0 % s.1);
        }
        s.0
    }

    pub fn extgcd<T>(a: T, b: T) -> (T, T, T)
    where
        T: Integer,
    {
        should!(a.is_non_negative(), b.is_non_negative());
        if b == T::ZERO {
            (T::ONE, T::ZERO, a)
        } else {
            let div_and_rem = T::div_and_remainder(a, b);
            let ans = extgcd(b, div_and_rem.1);
            (ans.1, ans.0 - div_and_rem.0 * ans.1, ans.2)
        }
    }

    pub fn inv_mod<T>(a: T, m: T) -> Option<T>
    where
        T: Integer,
    {
        let a1: T::SignedIntegerType = FromNumber::from(a);
        let m1: T::SignedIntegerType = FromNumber::from(m);
        let res = extgcd(a1, m1);
        if res.2 == T::SignedIntegerType::ONE {
            let res = T::from(T::SignedIntegerType::modular(res.0, m1));
            should_eq!(T::mul_mod(res, a, m), T::ONE);
            Some(res)
        } else {
            None
        }
    }
}
pub mod math {
    use crate::algebraic_structure::Field;
    use crate::algebraic_structure::Ring;
    use crate::arithmetic::IdentityMul;
    use crate::binary_search::first_true;
    use crate::binary_search::last_true;
    use crate::num_gcd::gcd;
    use crate::num_integer::Integer;
    use crate::num_number::FromNumber;
    use std::cmp::Ordering;

    pub fn pow<T, E>(x: T, n: E) -> T
    where
        T: Ring,
        E: Integer,
    {
        if n == E::ZERO {
            return <T as IdentityMul>::one();
        }
        let ans = pow(x, n >> E::ONE);
        let ans = ans * ans;
        if (n & E::ONE) == E::ONE {
            ans * x
        } else {
            ans
        }
    }

    pub fn log2_floor<T>(x: T) -> i32
    where
        T: Integer,
    {
        let leading_zero = x.count_leading_zero();
        T::BITS - leading_zero - 1
    }
    pub fn log2_ceil<T>(x: T) -> i32
    where
        T: Integer,
    {
        let res = log2_floor(x);
        if res < 0 || (T::ONE << FromNumber::from(res)) < x {
            res + 1
        } else {
            res
        }
    }

    pub fn argmax<'a, T: Ord>(data: &'a [T]) -> Option<(usize, &'a T)> {
        data.iter().enumerate().max_by_key(|(_, x)| *x)
    }

    pub fn argmin<'a, T: Ord>(data: &'a [T]) -> Option<(usize, &'a T)> {
        data.iter().enumerate().min_by_key(|(_, x)| *x)
    }

    pub fn argmax_by<'a, T>(
        data: &'a [T],
        f: &mut impl FnMut(&T, &T) -> Ordering,
    ) -> Option<(usize, &'a T)> {
        data.iter().enumerate().max_by(|(_, x), (_, y)| f(x, y))
    }

    pub fn argmin_by<'a, T>(
        data: &'a [T],
        f: &mut impl FnMut(&T, &T) -> Ordering,
    ) -> Option<(usize, &'a T)> {
        data.iter().enumerate().min_by(|(_, x), (_, y)| f(x, y))
    }

    pub fn sqrt_floor<T: Integer>(x: T) -> Option<T> {
        if x < T::ZERO {
            None
        } else {
            let x = x.as_unsigned();
            let limit: T = <T as FromNumber>::from(1) << <T as FromNumber>::from(T::BITS / 2);
            last_true(T::ZERO, limit - T::ONE, |t| (*t * *t).as_unsigned() <= x)
        }
    }

    pub fn sqrt_ceil<T: Integer>(x: T) -> Option<T> {
        if x < T::ZERO {
            None
        } else {
            let x = x.as_unsigned();
            let limit: T = <T as FromNumber>::from(1) << FromNumber::from(T::BITS / 2);
            match first_true(T::ZERO, limit - T::ONE, |t| (*t * *t).as_unsigned() >= x) {
                None => Some(limit + T::ONE),
                Some(x) => Some(x),
            }
        }
    }

    pub fn inverse_batch<T: Field>(mut data: &[T]) -> Vec<T> {
        if data.is_empty() {
            return Vec::new();
        }
        let n = data.len();
        let mut res = data.to_owned();
        for i in 1..n {
            res[i] = res[i - 1] * res[i];
        }
        let mut inv = T::one() / res[n - 1];
        for i in (1..n).rev() {
            res[i] = inv * res[i - 1];
            inv = inv * data[i];
        }
        res[0] = inv;
        res
    }

    pub fn max_batch<'a, T: Ord>(a: &'a [T]) -> Option<&'a T> {
        a.iter().max()
    }
    pub fn min_batch<'a, T: Ord>(a: &'a [T]) -> Option<&'a T> {
        a.iter().min()
    }
    pub fn dot_mul<T: Ring>(a: &Vec<T>, b: &Vec<T>) -> Vec<T> {
        a.iter().zip(b.iter()).map(|(x, y)| *x * *y).collect()
    }
}
pub mod num_float {
    use crate::num_concrete::Concrete;
    use crate::num_number::FromNumber;
    use crate::num_number::Number;
    use crate::num_real::Real;
    use std::fmt::Debug;
    use std::fmt::Display;
    use std::ops::Add;
    use std::ops::AddAssign;
    use std::ops::Div;
    use std::ops::DivAssign;
    use std::ops::Mul;
    use std::ops::MulAssign;
    use std::ops::Sub;
    use std::ops::SubAssign;
    use std::str::FromStr;

    #[derive(Clone, Copy)]
    pub struct float(f64);

    impl Real for float {
        const PI: Self = Self(3.1415926535897932384626433832795028841971693993751058209);

        const E: Self = Self(2.7182818284590452353602874713526624977572470936999595749);

        fn sqrt(&self) -> Self {
            Self(self.0.sqrt())
        }
        fn powf(&self, exp: Self) -> Self {
            Self(self.0.powf(exp.0))
        }
        fn powi(&self, exp: i32) -> Self {
            Self(self.0.powi(exp))
        }
        fn sin(&self) -> Self {
            Self(self.0.sin())
        }
        fn cos(&self) -> Self {
            Self(self.0.cos())
        }

        fn tan(&self) -> Self {
            Self(self.0.tan())
        }
        fn asin(&self) -> Self {
            Self(self.0.asin())
        }
        fn acos(&self) -> Self {
            Self(self.0.acos())
        }
        fn atan(&self) -> Self {
            Self(self.0.atan())
        }
        fn exp(&self) -> Self {
            Self(self.0.exp())
        }
        fn ln(&self) -> Self {
            Self(self.0.ln())
        }

        fn round(&self) -> Self {
            Self(f64::round(self.0))
        }
    }

    impl float {
        pub const MAX: Self = Self(f64::MAX);
        pub const MIN: Self = Self(f64::MIN);
        pub const ZERO: Self = Self(0.0);
        pub const ONE: Self = Self(1.0);
    }

    impl Add for float {
        type Output = Self;

        fn add(self, rhs: Self) -> Self::Output {
            Self(self.0 + rhs.0)
        }
    }
    impl AddAssign for float {
        fn add_assign(&mut self, rhs: Self) {
            self.0 += rhs.0;
        }
    }

    impl Sub for float {
        type Output = Self;

        fn sub(self, rhs: Self) -> Self::Output {
            Self(self.0 - rhs.0)
        }
    }
    impl SubAssign for float {
        fn sub_assign(&mut self, rhs: Self) {
            self.0 -= rhs.0
        }
    }
    impl Mul for float {
        type Output = Self;

        fn mul(self, rhs: Self) -> Self::Output {
            Self(self.0 * rhs.0)
        }
    }
    impl MulAssign for float {
        fn mul_assign(&mut self, rhs: Self) {
            self.0 *= rhs.0;
        }
    }

    impl Div for float {
        type Output = Self;

        fn div(self, rhs: Self) -> Self::Output {
            Self(self.0 / rhs.0)
        }
    }
    impl DivAssign for float {
        fn div_assign(&mut self, rhs: Self) {
            self.0 /= rhs.0;
        }
    }
    impl Debug for float {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            Debug::fmt(&self.0, f)
        }
    }
    impl Display for float {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl FromStr for float {
        type Err = ();

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match f64::from_str(s) {
                Ok(x) => Ok(Self(x)),
                Err(_) => Err(()),
            }
        }
    }
    impl FromNumber for float {
        fn from(num: impl crate::num_number::Number) -> Self {
            Self(num.as_f64())
        }
    }
    impl From<f64> for float {
        fn from(x: f64) -> Self {
            Self(x)
        }
    }
    impl From<f32> for float {
        fn from(x: f32) -> Self {
            Self(x as f64)
        }
    }
    impl PartialEq for float {
        fn eq(&self, other: &Self) -> bool {
            self.0 == other.0
        }
    }
    impl Eq for float {}
    impl PartialOrd for float {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            self.0.partial_cmp(&other.0)
        }
    }
    impl Ord for float {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            self.partial_cmp(other).unwrap()
        }
    }

    impl Number for float {
        const MAX: Self = float::MAX;

        const MIN: Self = float::MIN;

        const ZERO: Self = float::ZERO;

        const ONE: Self = float::ONE;

        type HighPrecisionType = float;

        type SignedType = float;

        fn upgrade(&self) -> Self::HighPrecisionType {
            *self
        }

        fn as_signed(&self) -> Self::SignedType {
            FromNumber::from(self.0)
        }

        fn as_i8(&self) -> i8 {
            self.0.as_i8()
        }

        fn as_u8(&self) -> u8 {
            self.0.as_u8()
        }

        fn as_i16(&self) -> i16 {
            self.0.as_i16()
        }

        fn as_u16(&self) -> u16 {
            self.0.as_u16()
        }

        fn as_i32(&self) -> i32 {
            self.0.as_i32()
        }

        fn as_u32(&self) -> u32 {
            self.0.as_u32()
        }

        fn as_i64(&self) -> i64 {
            self.0.as_i64()
        }

        fn as_u64(&self) -> u64 {
            self.0.as_u64()
        }

        fn as_i128(&self) -> i128 {
            self.0.as_i128()
        }

        fn as_u128(&self) -> u128 {
            self.0.as_u128()
        }

        fn as_isize(&self) -> isize {
            self.0.as_isize()
        }

        fn as_usize(&self) -> usize {
            self.0.as_usize()
        }

        fn as_f32(&self) -> f32 {
            self.0.as_f32()
        }

        fn as_f64(&self) -> f64 {
            self.0.as_f64()
        }
    }

    impl Concrete for float {}
}
use crate::math::pow;
use crate::num_float::float;
use crate::num_number::FromNumber;
use crate::num_number::Number;

impl Solution {
    pub fn my_pow(x: f64, n: i32) -> f64 {
        let mut n = n as i64;
        let mut x: float = FromNumber::from(x);
        if n < 0 {
            x = float::ONE / x;
            n = -n;
        }
        pow(x, n).as_f64()
    }
}

struct Solution;
fn main() {}
