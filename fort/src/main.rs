//Generated by https://github.com/taodaling/scheduler
//Timestamp: 2021-12-25 14:16:55
pub mod fast_input {
    use std::io;
    use std::io::BufRead;
    use std::io::BufReader;
    use std::io::Cursor;

    pub struct FastInput<R: std::io::BufRead> {
        inner: R,
        line: Vec<u8>,
        offset: usize,
    }

    pub fn new_fastinput_from_string(s: String) -> FastInput<BufReader<Cursor<String>>> {
        let x = FastInput::new(BufReader::new(Cursor::new(s)));
        x
    }

    pub fn new_fastinput_from_string_ref(s: &String) -> FastInput<BufReader<Cursor<&String>>> {
        let x = FastInput::new(BufReader::new(Cursor::new(s)));
        x
    }

    impl<R: std::io::BufRead> FastInput<R> {
        pub fn new(inner: R) -> Self {
            FastInput {
                inner,
                line: Vec::with_capacity(1 << 15),
                offset: 0,
            }
        }

        fn next(&mut self) -> Option<&str> {
            while self.offset < self.line.len() && self.line[self.offset] <= 32 {
                self.offset += 1;
            }
            if self.offset == self.line.len() {
                return None;
            }
            let begin = self.offset;
            let mut end = self.offset + 1;
            while end < self.line.len() && self.line[end] > 32 {
                end += 1;
            }
            self.offset = end;
            unsafe { Some(std::str::from_utf8_unchecked(&self.line[begin..end])) }
        }

        pub fn read<T: std::str::FromStr>(&mut self) -> T {
            loop {
                match self.next() {
                    Some(token) => {
                        return token.parse().ok().expect("Wrong format input");
                    }
                    None => {
                        self.line.clear();
                        self.inner.read_until(b'\n', &mut self.line).unwrap();
                        self.offset = 0;
                    }
                }
            }
        }

        pub fn r<T: std::str::FromStr>(&mut self) -> T {
            self.read()
        }

        pub fn ri(&mut self) -> i32 {
            let res: i32 = self.read();
            return res;
        }

        pub fn rl(&mut self) -> i64 {
            let res: i64 = self.read();
            return res;
        }

        pub fn rf(&mut self) -> f64 {
            let res: f64 = self.read();
            return res;
        }

        pub fn rs(&mut self) -> String {
            let res: String = self.read();
            return res;
        }

        pub fn ru(&mut self) -> usize {
            let res: usize = self.read();
            return res;
        }
    }
}
pub mod template_macro {
    #[cfg(feature = "local-build")]
    macro_rules! should {
    ($($e: expr),*) => {
        $(
            assert!($e);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! should_eq {
    ($($a: expr, $b: expr);*) => {
        $(
            assert_eq!($a, $b);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should_eq {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug {
        ($e: expr) => {
            std::convert::identity($e)
        };
    }

    pub(crate) use debug;
    pub(crate) use should;
    pub(crate) use should_eq;
}
pub mod general_graph_match {
    use crate::template_macro::should;
    use std::mem::swap;

    pub struct GeneralGraphMatch {
        n: usize,
        pre: Vec<usize>,
        edges: Vec<Vec<bool>>,
        mate: Vec<usize>,
        link: Vec<usize>,
        vis: Vec<usize>,
        fa: Vec<usize>,
        que: Vec<usize>,
        hd: usize,
        tl: usize,
        ss: Vec<usize>,
        tim: usize,
    }

    impl GeneralGraphMatch {
        pub fn new(n: usize) -> Self {
            let len = n + 1;
            Self {
                n,
                pre: vec![0; len],
                edges: vec![vec![false; len]; len],
                mate: vec![0; len],
                link: vec![0; len],
                vis: vec![0; len],
                fa: vec![0; len],
                que: vec![0; len],
                ss: vec![0; len],
                hd: 0,
                tl: 0,
                tim: 0,
            }
        }

        fn find(&mut self, x: usize) -> usize {
            if self.fa[x] == x {
            } else {
                self.fa[x] = self.find(self.fa[x]);
            }
            self.fa[x]
        }
        fn lca(&mut self, mut x: usize, mut y: usize) -> usize {
            self.tim += 1;
            while self.ss[x] != self.tim {
                if x != 0 {
                    self.ss[x] = self.tim;
                    x = self.find(self.link[self.mate[x]]);
                }
                swap(&mut x, &mut y);
            }
            x
        }

        fn flower(&mut self, mut x: usize, mut y: usize, p: usize) {
            while self.find(x) != p {
                self.link[x] = y;
                y = self.mate[x];
                self.fa[y] = p;
                self.fa[x] = p;
                if self.vis[y] == 1 {
                    self.que[self.tl] = y;
                    self.vis[y] = 2;
                    self.tl += 1;
                }
                x = self.link[y];
            }
        }

        pub fn try_match(&mut self, mut x: usize) -> bool {
            self.hd = 0;
            self.tl = 0;
            for i in 1..=self.n {
                self.fa[i] = i;
                self.vis[i] = 0;
            }
            self.que[self.tl] = x;
            self.vis[x] = 2;
            self.tl += 1;
            while self.hd < self.tl {
                x = self.que[self.hd];
                self.hd += 1;
                for mut u in 1..=self.n {
                    if !self.edges[x][u] {
                        continue;
                    }
                    if self.vis[u] == 0 {
                        self.vis[u] = 1;
                        self.link[u] = x;
                        if self.mate[u] == 0 {
                            while x != 0 {
                                x = self.mate[self.link[u]];
                                self.mate[u] = self.link[u];
                                self.mate[self.link[u]] = u;
                                u = x;
                            }
                            return true;
                        } else {
                            self.que[self.tl] = self.mate[u];
                            self.vis[self.mate[u]] = 2;
                            self.tl += 1;
                        }
                    } else if self.vis[u] == 2 && self.find(u) != self.find(x) {
                        let p = self.lca(x, u);
                        self.flower(x, u, p);
                        self.flower(u, x, p);
                    }
                }
            }
            false
        }
        pub fn delete_edge_if_not_derease_matching_number(
            &mut self,
            mut a: usize,
            mut b: usize,
        ) -> bool {
            a += 1;
            b += 1;
            should!(self.edges[a][b]);
            if self.mate[a] != b {
                self.edges[a][b] = false;
                self.edges[b][a] = false;
                return true;
            }
            self.mate[a] = 0;
            self.mate[b] = 0;
            self.edges[a][b] = false;
            self.edges[b][a] = false;
            if self.try_match(a) || self.try_match(b) {
                return true;
            }
            self.mate[a] = b;
            self.mate[b] = a;
            self.edges[a][b] = true;
            self.edges[b][a] = true;
            return false;
        }

        pub fn mate(&self, mut i: usize) -> Option<usize> {
            let i = i + 1;
            if self.mate[i] == 0 {
                None
            } else {
                Some(self.mate[i] - 1)
            }
        }

        pub fn add_edge(&mut self, x: usize, y: usize) {
            let x = x + 1;
            let y = y + 1;
            self.edges[x][y] = true;
            self.edges[y][x] = true;
        }

        pub fn max_match(&mut self, greedy: bool, perm: &[usize]) -> usize {
            let mut total = 0;
            if greedy {
                for i in 1..=self.n {
                    for j in i + 1..=self.n {
                        if self.edges[i][j] && self.mate[i] == 0 && self.mate[j] == 0 {
                            self.mate[i] = j;
                            self.mate[j] = i;
                            total += 1;
                        }
                    }
                }
            }

            for i in perm {
                let i = i + 1;
                if self.mate[i] == 0 && self.try_match(i) {
                    total += 1;
                }
            }

            total
        }
    }
}
pub mod contest_macro {
    #[cfg(feature = "local-build")]
    macro_rules! should {
    ($($e: expr),*) => {
        $(
            assert!($e);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! should_eq {
    ($($a: expr, $b: expr);*) => {
        $(
            assert_eq!($a, $b);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should_eq {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug {
        ($e: expr) => {
            std::convert::identity($e)
        };
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug_discard {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug_discard {
        ($e: expr) => {};
    }

    macro_rules! input {
    ($fi:ident, $($var:ident$( : $t:ty)?),*) => {
        $(
            let mut $var $(: $t)? = $fi.read();
        )*
    };
}

    pub(crate) use debug;
    pub(crate) use debug_discard;
    pub(crate) use input;
    pub(crate) use should;
    pub(crate) use should_eq;
}
pub mod solver {
    use crate::contest_macro::input;
    use crate::fast_input::FastInput;
    use crate::general_graph_match::GeneralGraphMatch;
    use std::io::BufRead;
    use std::io::Write;
    use std::panic;

    pub unsafe fn solve_one<I: BufRead>(test_id: u32, fi: &mut FastInput<I>, fo: &mut impl Write) {
        input!(fi, n, m);
        let mut gm = GeneralGraphMatch::new(n);
        for i in 0..m {
            input!(fi, u, v);
            gm.add_edge(u, v);
        }
        let perm: Vec<usize> = (0..n).into_iter().collect();
        let cnt = gm.max_match(true, &perm[..]);
        writeln!(fo, "{}", cnt);
        for i in 0..n {
            if let Some(j) = gm.mate(i) {
                if j > i {
                    writeln!(fo, "{} {}", i, j);
                }
            }
        }
    }

    pub unsafe fn solve_multi<I: BufRead>(fi: &mut FastInput<I>, fo: &mut impl Write) {
        let t: u32 = 1;
        for test_id in 1..t + 1 {
            solve_one(test_id, fi, fo);
        }
    }
}
pub mod rand {
    struct xorshift128p_state(u64, u64);

    #[cfg(feature = "local-build")]
    fn seed() -> u64 {
        dbg!("use fix seed 0");
        0
    }

    #[cfg(not(feature = "local-build"))]
    fn seed() -> u64 {
        let start = std::time::SystemTime::now();
        start
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }

    fn splitmix64(state: &mut u64) -> u64 {
        *state += 0x9E3779B97f4A7C15;
        let mut result = *state;
        result = (result ^ (result >> 30)) * 0xBF58476D1CE4E5B9;
        result = (result ^ (result >> 27)) * 0x94D049BB133111EB;
        return result ^ (result >> 31);
    }

    fn xorshift128p_init(seed: u64) -> xorshift128p_state {
        let mut smstate = seed;
        let mut result = xorshift128p_state(0, 0);

        result.0 = splitmix64(&mut smstate);
        result.1 = splitmix64(&mut smstate);

        result
    }

    fn xorshift128p(state: &mut xorshift128p_state) -> u64 {
        let mut t = state.0;
        let s = state.1;
        state.0 = s;
        t ^= t << 32;
        t ^= t >> 18;
        t ^= s ^ (s >> 5);
        state.1 = t;
        t + s
    }

    pub fn rng() -> &'static mut Rng {
        static mut singleton: Option<Rng> = None;
        unsafe {
            match &mut singleton {
                Some(x) => x,
                None => {
                    singleton = Some(Rng::new());
                    rng()
                }
            }
        }
    }

    pub struct Rng {
        state: xorshift128p_state,
    }

    impl Rng {
        pub fn new() -> Self {
            Self {
                state: xorshift128p_init(seed()),
            }
        }
        pub fn init(&mut self, seed: u64) {
            self.state = xorshift128p_init(seed);
        }
        pub fn new_with_seed(seed: u64) -> Self {
            Self {
                state: xorshift128p_init(seed),
            }
        }

        pub fn u64(&mut self) -> u64 {
            xorshift128p(&mut self.state)
        }
        pub fn usize(&mut self) -> usize {
            self.u64() as usize
        }
        pub fn f64(&mut self) -> f64 {
            loop {
                let res = self.u64();
                if res < u64::MAX {
                    return res as f64 / usize::MAX as f64;
                }
            }
        }
        pub fn limit_usize(&mut self, n: usize) -> usize {
            self.limit_u64(n as u64) as usize
        }
        pub fn limit_u64(&mut self, n: u64) -> u64 {
            (self.f64() * n as f64) as u64
        }
        pub fn range_u64(&mut self, l: u64, r: u64) -> u64 {
            let n = r - l + 1;
            self.limit_u64(r - l + 1) + l
        }
        pub fn range_usize(&mut self, l: usize, r: usize) -> usize {
            self.range_u64(l as u64, r as u64) as usize
        }
    }
}
pub mod stress_external_member {
    use crate::fast_input::FastInput;
    use crate::rand::Rng;
    use std::io::BufRead;
    use std::io::Write;
    use std::mem::swap;

    pub unsafe fn brute_force<InT>(fi: &mut FastInput<InT>, fo: &mut impl Write)
    where
        InT: BufRead,
    {
    }

    pub fn generate_test(rng: &mut Rng, fo: &mut impl Write) {}

    pub fn against(a: &String, b: &String) -> bool {
        let da: Vec<_> = a.split_ascii_whitespace().collect();
        let db: Vec<_> = b.split_ascii_whitespace().collect();
        da == db
    }
}
pub mod stress {
    use crate::fast_input::FastInput;
    use crate::rand::rng;
    use crate::rand::Rng;
    use crate::solver::solve_multi;
    use crate::stress_external_member::against;
    use crate::stress_external_member::brute_force;
    use crate::stress_external_member::generate_test;
    use std::fmt::Display;
    use std::io::BufReader;
    use std::io::Cursor;
    use std::io::Write;

    fn printable_input(s: String) -> String {
        let len = 1000;
        if s.len() < len {
            s
        } else {
            s[0..len].to_string() + "..."
        }
    }

    pub unsafe fn stress() {
        let mut round = 0;
        let mut rng_for_input_generator = Rng::new_with_seed(0);
        loop {
            round += 1;
            if round >= 10000 {
                println!("Pass stress!");
                return;
            }
            rng().init(0);

            let mut input = OutputWrapper::new();
            generate_test(&mut rng_for_input_generator, &mut input);
            println!("Test {}:", round);
            println!("{}\n", printable_input(input.to_string()));
            let mut actual_output = OutputWrapper::new();
            let mut expect_output = OutputWrapper::new();
            solve_multi(
                &mut FastInput::new(BufReader::new(Cursor::new(input.to_string()))),
                &mut actual_output,
            );
            brute_force(
                &mut FastInput::new(BufReader::new(Cursor::new(input.to_string()))),
                &mut expect_output,
            );
            if !against(&actual_output.to_string(), &expect_output.to_string()) {
                println!("Test case {}:", round);
                println!("\nInput:\n{}", input);
                println!("\nExpect:\n{}", expect_output);
                println!("\nActual:\n{}", actual_output);
                panic!("Fail!");
            }
        }
    }
    struct OutputWrapper(Vec<u8>);
    impl OutputWrapper {
        pub fn new() -> OutputWrapper {
            OutputWrapper(Vec::new())
        }
    }
    impl Display for OutputWrapper {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = String::from_utf8(self.0.clone()).unwrap();
            f.write_str(s.as_str())
        }
    }
    impl Write for OutputWrapper {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let mut to = buf.iter().map(|x| *x).collect();
            self.0.append(&mut to);
            Ok(buf.len())
        }

        fn flush(&mut self) -> std::io::Result<()> {
            Ok(())
        }
    }
}
use crate::fast_input::FastInput;
use crate::solver::solve_multi;
use crate::stress::stress;
use std::io::BufWriter;
use std::thread;

#[allow(dead_code)]
unsafe fn run_in_current_thread() {
    let stdin = std::io::stdin();
    let stdout = std::io::stdout();
    let mut fi = FastInput::new(stdin.lock());
    let mut fo = BufWriter::new(stdout.lock());
    solve_multi(&mut fi, &mut fo);
}

#[allow(dead_code)]
unsafe fn run_in_new_thread() {
    thread::Builder::new()
        .stack_size(256 << 20)
        .spawn(|| {
            run_in_current_thread();
        })
        .unwrap()
        .join();
}
#[cfg(not(feature = "stress"))]
fn main() {
    unsafe {
        run_in_current_thread();
    }
}

#[cfg(feature = "stress")]
fn main() {
    unsafe {
        stress();
    }
}
