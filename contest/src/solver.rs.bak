use std::{io::{StdinLock, BufWriter, StdoutLock, Write}, panic, cmp::min, ops::Add, mem::swap};
use crate::{fast_input::FastInput, util::debug, arithmetic::*, graph::SimpleDiEdge, root_tree::EulerTourTrace, range_minimum_query::RangeMinimumQuery};
type E = SimpleDiEdge;

pub unsafe fn solve_one(test_id: u32, fi: &mut FastInput<StdinLock>, fo: &mut BufWriter<StdoutLock>) {
    let n = fi.ru();
    let q = fi.ru();
    let mut adj = vec![Vec::new(); n];
    for i in 1..n {
        let a = i;
        let b = fi.ru();
        adj[a].push(E::new(b));
        adj[b].push(E::new(a));
    }
    let mut adj = debug!(adj);
    let mut euler_tour = debug!(EulerTourTrace::new(&adj, |x| x == 0));
    let rmq = RangeMinimumQuery::new(euler_tour.euler_trace.iter().map(|x| euler_tour.first_seen[*x])
        .collect());
    for _ in 0..q {
        let u = fi.ru();
        let v = fi.ru();
        let (u, v) = debug!((u, v));
        let mut l = euler_tour.first_seen[u];
        let mut r = euler_tour.first_seen[v];
        if l > r {
            swap(&mut l, &mut r);
        }
        let (l, r) = debug!((l, r));
        let lca_order = rmq.query(l, r);
        let lca = euler_tour.euler_trace[lca_order];
        writeln!(fo, "{}", lca);
    }
}
  
pub unsafe fn solve_multi(fi: &mut FastInput<StdinLock>, fo: &mut BufWriter<StdoutLock>) {
    let t: u32 = 1;//fi.read();
    for test_id in 1 .. t + 1 {
        solve_one(test_id, fi, fo);
    }
}