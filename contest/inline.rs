//Generated by https://github.com/taodaling/scheduler
//Timestamp: 2021-12-28 00:53:40
pub mod fast_input {
    use std::io;
    use std::io::BufRead;
    use std::io::BufReader;
    use std::io::Cursor;

    pub struct FastInput<R: std::io::BufRead> {
        inner: R,
        line: Vec<u8>,
        offset: usize,
    }

    pub fn new_fastinput_from_string(s: String) -> FastInput<BufReader<Cursor<String>>> {
        let x = FastInput::new(BufReader::new(Cursor::new(s)));
        x
    }

    pub fn new_fastinput_from_string_ref(s: &String) -> FastInput<BufReader<Cursor<&String>>> {
        let x = FastInput::new(BufReader::new(Cursor::new(s)));
        x
    }

    impl<R: std::io::BufRead> FastInput<R> {
        pub fn new(inner: R) -> Self {
            FastInput {
                inner,
                line: Vec::with_capacity(1 << 15),
                offset: 0,
            }
        }

        fn next(&mut self) -> Option<&str> {
            while self.offset < self.line.len() && self.line[self.offset] <= 32 {
                self.offset += 1;
            }
            if self.offset == self.line.len() {
                return None;
            }
            let begin = self.offset;
            let mut end = self.offset + 1;
            while end < self.line.len() && self.line[end] > 32 {
                end += 1;
            }
            self.offset = end;
            unsafe { Some(std::str::from_utf8_unchecked(&self.line[begin..end])) }
        }

        pub fn read<T: std::str::FromStr>(&mut self) -> T {
            loop {
                match self.next() {
                    Some(token) => {
                        return token.parse().ok().expect("Wrong format input");
                    }
                    None => {
                        self.line.clear();
                        self.inner.read_until(b'\n', &mut self.line).unwrap();
                        self.offset = 0;
                    }
                }
            }
        }

        pub fn r<T: std::str::FromStr>(&mut self) -> T {
            self.read()
        }

        pub fn ri(&mut self) -> i32 {
            let res: i32 = self.read();
            return res;
        }

        pub fn rl(&mut self) -> i64 {
            let res: i64 = self.read();
            return res;
        }

        pub fn rf(&mut self) -> f64 {
            let res: f64 = self.read();
            return res;
        }

        pub fn rs(&mut self) -> String {
            let res: String = self.read();
            return res;
        }

        pub fn ru(&mut self) -> usize {
            let res: usize = self.read();
            return res;
        }
    }
}
pub mod num_number {
    use std::fmt::Debug;
    use std::fmt::Display;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;
    use std::str::FromStr;

    pub trait Number:
        Copy
        + Add<Output = Self>
        + Sub<Output = Self>
        + Mul<Output = Self>
        + Div<Output = Self>
        + PartialEq
        + PartialOrd
        + Display
        + Debug
        + FromStr
    {
        const MAX: Self;
        const MIN: Self;
        const ZERO: Self;
        const ONE: Self;

        type HighPrecisionType: Number;
        type SignedType: Number;

        fn upgrade(&self) -> Self::HighPrecisionType {
            Self::HighPrecisionType::from_number(*self)
        }

        fn as_i8(&self) -> i8;
        fn as_i16(&self) -> i16;
        fn as_i32(&self) -> i32;
        fn as_i64(&self) -> i64;
        fn as_i128(&self) -> i128;
        fn as_u8(&self) -> u8;
        fn as_u16(&self) -> u16;
        fn as_u32(&self) -> u32;
        fn as_u64(&self) -> u64;
        fn as_u128(&self) -> u128;
        fn as_f32(&self) -> f32;
        fn as_f64(&self) -> f64;
        fn as_isize(&self) -> isize;
        fn as_usize(&self) -> usize;
        fn from_i8(x: i8) -> Self;
        fn from_i16(x: i16) -> Self;
        fn from_i32(x: i32) -> Self;
        fn from_i64(x: i64) -> Self;
        fn from_i128(x: i128) -> Self;
        fn from_isize(x: isize) -> Self;
        fn from_u8(x: u8) -> Self;
        fn from_u16(x: u16) -> Self;
        fn from_u32(x: u32) -> Self;
        fn from_u64(x: u64) -> Self;
        fn from_u128(x: u128) -> Self;
        fn from_usize(x: usize) -> Self;
        fn from_f64(x: f64) -> Self;
        fn from_f32(x: f32) -> Self;
        fn from_number(x: impl Number) -> Self;
        fn sign(&self) -> i8 {
            if self.is_negative() {
                -1
            } else if self.is_positive() {
                1
            } else {
                0
            }
        }
        fn negative(&self) -> Self {
            Self::ZERO - *self
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
        fn is_positive(&self) -> bool {
            *self > Self::ZERO
        }
        fn is_non_negative(&self) -> bool {
            *self >= Self::ZERO
        }
        fn is_non_positive(&self) -> bool {
            *self <= Self::ZERO
        }
        fn absolute(&self) -> Self {
            if self.is_negative() {
                self.negative()
            } else {
                *self
            }
        }
        fn as_signed(&self) -> Self::SignedType;
    }

    macro_rules! Generator {
        ($t: ty, $as_method: ident, $H: ident) => {
            Generator!($t, $t, $as_method, $H);
        };
        ($t: ty, $s: ty, $as_method: ident, $H: ident) => {
            impl Number for $t {
                type SignedType = $s;
                type HighPrecisionType = $H;
                const MAX: Self = <$t>::MAX;
                const MIN: Self = <$t>::MIN;
                const ZERO: Self = 0 as Self;
                const ONE: Self = 1 as Self;

                fn from_number(x: impl Number) -> Self {
                    x.$as_method()
                }

                fn as_i8(&self) -> i8 {
                    *self as i8
                }

                fn as_i16(&self) -> i16 {
                    *self as i16
                }

                fn as_i32(&self) -> i32 {
                    *self as i32
                }

                fn as_i64(&self) -> i64 {
                    *self as i64
                }

                fn as_i128(&self) -> i128 {
                    *self as i128
                }

                fn as_f32(&self) -> f32 {
                    *self as f32
                }

                fn as_f64(&self) -> f64 {
                    *self as f64
                }

                fn as_isize(&self) -> isize {
                    *self as isize
                }

                fn absolute(&self) -> Self {
                    if self.is_negative() {
                        self.negative()
                    } else {
                        *self
                    }
                }

                fn from_i8(x: i8) -> Self {
                    x as Self
                }

                fn from_i16(x: i16) -> Self {
                    x as Self
                }

                fn from_i32(x: i32) -> Self {
                    x as Self
                }

                fn from_i64(x: i64) -> Self {
                    x as Self
                }

                fn from_i128(x: i128) -> Self {
                    x as Self
                }

                fn from_isize(x: isize) -> Self {
                    x as Self
                }

                fn from_f64(x: f64) -> Self {
                    x as Self
                }

                fn from_f32(x: f32) -> Self {
                    x as Self
                }

                fn as_u8(&self) -> u8 {
                    *self as u8
                }

                fn as_u16(&self) -> u16 {
                    *self as u16
                }

                fn as_u32(&self) -> u32 {
                    *self as u32
                }

                fn as_u64(&self) -> u64 {
                    *self as u64
                }

                fn as_u128(&self) -> u128 {
                    *self as u128
                }

                fn as_usize(&self) -> usize {
                    *self as usize
                }

                fn from_u8(x: u8) -> Self {
                    x as Self
                }

                fn from_u16(x: u16) -> Self {
                    x as Self
                }

                fn from_u32(x: u32) -> Self {
                    x as Self
                }

                fn from_u64(x: u64) -> Self {
                    x as Self
                }

                fn from_u128(x: u128) -> Self {
                    x as Self
                }

                fn from_usize(x: usize) -> Self {
                    x as Self
                }

                fn as_signed(&self) -> Self::SignedType {
                    *self as Self::SignedType
                }
            }
        };
    }

    Generator!(usize, as_usize, u64);
    Generator!(isize, as_isize, i64);

    Generator!(i8, as_i8, i16);
    Generator!(i16, as_i16, i32);
    Generator!(i32, as_i32, i64);
    Generator!(i64, as_i64, i128);
    Generator!(i128, as_i128, i128);

    Generator!(u8, i8, as_u8, u16);
    Generator!(u16, i16, as_u16, u32);
    Generator!(u32, i32, as_u32, u64);
    Generator!(u64, i64, as_u64, u128);
    Generator!(u128, i128, as_u128, u128);

    Generator!(f32, as_f32, f64);
    Generator!(f64, as_f64, f64);
}
pub mod num_integer {
    use crate::num_number::Number;
    use std::ops::BitAnd;
    use std::ops::BitOr;
    use std::ops::BitXor;
    use std::ops::Not;
    use std::ops::Rem;
    use std::ops::Shl;
    use std::ops::Shr;

    pub trait Integer:
        Number
        + Rem<Output = Self>
        + Shl<Output = Self>
        + Shr<Output = Self>
        + BitAnd<Output = Self>
        + BitOr<Output = Self>
        + BitXor<Output = Self>
        + Not<Output = Self>
        + Ord
    {
        type UnsignedType: Integer;
        const BITS: i32;

        fn bit_count(&self) -> i32;
        fn higest_set_bit_offset(&self) -> i32;
        fn lowest_set_bit(&self) -> Self;
        fn higest_one_bit(&self) -> Self;
        fn count_leading_zero(&self) -> i32;
        fn count_trailing_zero(&self) -> i32;
        fn modular(a: Self, m: Self) -> Self {
            let res = a % m;
            if res.is_negative() {
                res + m
            } else {
                res
            }
        }
        fn mul_mod(a: Self, b: Self, m: Self) -> Self;
        fn pow_mod(a: Self, n: u64, m: Self) -> Self {
            if n == 0 {
                Self::ONE
            } else {
                let ans = Self::pow_mod(a, n >> 1, m);
                let ans = Self::mul_mod(ans, ans, m);
                if (n & 1) == 1 {
                    Self::mul_mod(ans, a, m)
                } else {
                    ans
                }
            }
        }
        fn pow(a: Self, mut n: u32) -> Self {
            let mut ans = a;
            while n > 1 {
                n -= 1u32;
                ans = ans * a;
            }
            ans
        }
        fn average_floor(a: Self, b: Self) -> Self {
            (a & b) + ((a ^ b) >> Self::from_i8(1))
        }
        fn average_ceil(a: Self, b: Self) -> Self {
            (a | b) - ((a ^ b) >> Self::from_i8(1))
        }
        fn add_overflow(a: Self, b: Self) -> (Self, bool);
        fn add_or_default(a: Self, b: Self, def: Self) -> (Self, bool) {
            let mut res = Self::add_overflow(a, b);
            if res.1 {
                res.0 = def;
            }
            res
        }
        fn mul_or_default(a: Self, b: Self, def: Self) -> (Self, bool) {
            let mut res = Self::mul_overflow(a, b);
            if res.1 {
                res.0 = def;
            }
            res
        }
        fn bit_left_shift(&self, step: i32) -> Self {
            if step >= Self::BITS {
                Self::ZERO
            } else {
                *self << Self::from_i32(step)
            }
        }
        fn bit_signed_right_shift(&self, step: i32) -> Self;
        fn bit_unsigned_right_shift(&self, step: i32) -> Self;

        fn mul_overflow(a: Self, b: Self) -> (Self, bool);
        fn div_and_remainder(a: Self, b: Self) -> (Self, Self);
    }

    macro_rules! IntegerImpl {
        ($t: ty, $h: ty, $u: ty) => {
            impl Integer for $t {
                type UnsignedType = $u;
                const BITS: i32 = <$t>::BITS as i32;
                fn count_trailing_zero(&self) -> i32 {
                    let x = 0;
                    if *self == <$t as Number>::ZERO {
                        <Self as Integer>::BITS
                    } else {
                        <Self as Integer>::BITS - 1 - self.lowest_set_bit().count_leading_zero()
                    }
                }
                fn bit_signed_right_shift(&self, step: i32) -> Self {
                    if step >= <Self as Integer>::BITS {
                        if self.is_negative() {
                            !Self::ZERO
                        } else {
                            Self::ZERO
                        }
                    } else {
                        ((*self as Self::SignedType) >> (step as Self::SignedType)) as Self
                    }
                }

                fn bit_unsigned_right_shift(&self, step: i32) -> Self {
                    if step >= <Self as Integer>::BITS {
                        Self::ZERO
                    } else {
                        ((*self as Self::UnsignedType) >> (step as Self::UnsignedType)) as Self
                    }
                }

                fn mul_mod(a: Self, b: Self, m: Self) -> Self {
                    let mut res = ((a as Self::HighPrecisionType * b as Self::HighPrecisionType)
                        % (m as Self::HighPrecisionType)) as Self;
                    if res.is_negative() {
                        res = res + m;
                    }
                    res
                }

                fn add_overflow(a: Self, b: Self) -> (Self, bool) {
                    Self::overflowing_add(a, b)
                }

                fn mul_overflow(a: Self, b: Self) -> (Self, bool) {
                    Self::overflowing_mul(a, b)
                }

                fn bit_count(&self) -> i32 {
                    self.count_ones() as i32
                }

                fn higest_set_bit_offset(&self) -> i32 {
                    (Self::BITS - 1 - self.leading_zeros()) as i32
                }

                fn lowest_set_bit(&self) -> Self {
                    *self & self.negative()
                }

                fn higest_one_bit(&self) -> Self {
                    if *self == Self::ZERO {
                        0
                    } else {
                        Self::ONE << Self::from_i32(self.higest_set_bit_offset())
                    }
                }

                fn count_leading_zero(&self) -> i32 {
                    self.leading_zeros() as i32
                }

                fn div_and_remainder(a: Self, b: Self) -> (Self, Self) {
                    let d = a / b;
                    (d, a - d * b)
                }
            }
        };
    }

    IntegerImpl!(i8, i16, u8);
    IntegerImpl!(u8, i16, u8);
    IntegerImpl!(i16, i32, u16);
    IntegerImpl!(u16, u32, u16);
    IntegerImpl!(i32, i64, u32);
    IntegerImpl!(u32, u64, u32);
    IntegerImpl!(isize, isize, usize);
    IntegerImpl!(usize, usize, usize);
    IntegerImpl!(i64, i128, u64);
    IntegerImpl!(u64, u128, u64);
    IntegerImpl!(i128, i128, u128);
    IntegerImpl!(u128, u128, u128);
}
pub mod num_real {
    use crate::num_number::Number;

    pub trait Real: Number {
        fn average(a: Self, b: Self) -> Self {
            (a + b) / Self::from_i8(2)
        }
    }

    macro_rules! RealImpl {
        ($name: ident) => {
            impl Real for $name {}
        };
    }

    RealImpl!(f32);
    RealImpl!(f64);
}
pub mod template_macro {
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;

    #[cfg(feature = "local-build")]
    macro_rules! should {
    ($($e: expr),*) => {
        $(
            assert!($e);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! should_eq {
    ($($a: expr, $b: expr);*) => {
        $(
            assert_eq!($a, $b);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should_eq {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug {
        ($e: expr) => {
            std::convert::identity($e)
        };
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug_discard {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug_discard {
        ($e: expr) => {};
    }

    macro_rules! input {
    ($fi:ident, $($var:ident$( : $t:ty)?),*) => {
        $(
            let mut $var $(: $t)? = $fi.read();
        )*
    };
}

    macro_rules! MergerImpl {
        ($name: ident, $A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            struct $name;
            impl Merger<$A, $B, $C> for $name {
                fn merge($a: $A, $b: $B) -> $C {
                    $body
                }
            }
        };
    }
    macro_rules! AddImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Add<$B> for $A {
                type Output = $C;

                fn add(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }
    macro_rules! SubImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Mul<$B> for $A {
                type Output = $C;

                fn sub(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }
    macro_rules! DivImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Mul<$B> for $A {
                type Output = $C;

                fn div(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }
    macro_rules! MulImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Sub<$B> for $A {
                type Output = $C;

                fn mul(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }

    pub(crate) use debug;
    pub(crate) use debug_discard;
    pub(crate) use input;
    pub(crate) use should;
    pub(crate) use should_eq;
    pub(crate) use AddImpl;
    pub(crate) use DivImpl;
    pub(crate) use MergerImpl;
    pub(crate) use MulImpl;
    pub(crate) use SubImpl;
}
pub mod arithmetic {
    use crate::num_integer::Integer;
    use crate::num_number::Number;
    use crate::num_real::Real;
    use crate::template_macro::should;
    use std::fmt::Debug;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;

    pub trait CommutativeAdd: Add<Output = Self> + Copy + Debug {}
    pub trait AssociativeAdd: Add<Output = Self> + Copy + Debug {}
    pub trait IdentityAdd: Add<Output = Self> + Copy + Debug {
        fn zero() -> Self;
    }
    pub trait CommutativeMul: Mul<Output = Self> + Copy + Debug {}
    pub trait AssociativeMul: Mul<Output = Self> + Copy + Debug {}
    pub trait IdentityMul: Mul<Output = Self> + Copy + Debug {
        fn one() -> Self;
    }
    pub trait IdempotentAdd: CommutativeAdd + AssociativeAdd {}
    pub trait IdempotentMul: CommutativeMul + AssociativeMul {}
    pub trait IntegralMul: Mul<Output = Self> + Copy + Debug {}
    impl<T> IntegralMul for T where T: Div<Output = Self> + Mul<Output = Self> + Copy + Debug {}

    pub trait PreferDiv: Div<Output = Self> + Copy + Debug {
        fn div_ceil(a: Self, b: Self) -> Self {
            a / b
        }
        fn div_floor(a: Self, b: Self) -> Self {
            a / b
        }
    }

    impl PreferDiv for f32 {}
    impl PreferDiv for f64 {}
    impl<T: Integer> PreferDiv for T {
        fn div_ceil(a: Self, b: Self) -> Self {
            should!(b >= Self::ZERO);
            let res = a / b;
            if res * b > a {
                res - Self::ONE
            } else {
                res
            }
        }
        fn div_floor(a: Self, b: Self) -> Self {
            should!(b >= Self::ZERO);
            let res = a / b;
            if res * b < a {
                res + Self::ONE
            } else {
                res
            }
        }
    }

    pub trait LowerBound: PartialOrd {
        fn min_element() -> Self;
    }

    pub trait UpperBound: PartialOrd {
        fn max_element() -> Self;
    }

    macro_rules! LiteAddGenerator {
        ($t: ty, $zero: expr) => {
            impl CommutativeAdd for $t {}
            impl IdentityAdd for $t {
                fn zero() -> Self {
                    $zero
                }
            }
            impl AssociativeAdd for $t {}
        };
    }

    macro_rules! AddGenerator {
        ($t: ty, $zero: expr) => {
            LiteAddGenerator!($t, $zero);
            impl IdempotentAdd for $t {}
        };
    }

    macro_rules! LiteMulGenerator {
        ($t: ty, $one: expr) => {
            impl CommutativeMul for $t {}
            impl IdentityMul for $t {
                fn one() -> Self {
                    $one
                }
            }
            impl AssociativeMul for $t {}
        };
    }

    macro_rules! MulGenerator {
        ($t: ty, $one: expr) => {
            LiteMulGenerator!($t, $one);
            impl IdempotentMul for $t {}
        };
    }

    macro_rules! AllGenerator {
        ($t: ty, $zero: expr, $one: expr) => {
            AddGenerator!($t, $zero);
            MulGenerator!($t, $one);
        };
    }

    impl<T> CommutativeAdd for T where T: Number {}
    impl<T> IdentityAdd for T
    where
        T: Number,
    {
        fn zero() -> Self {
            <T as Number>::ZERO
        }
    }
    impl<T> AssociativeAdd for T where T: Number {}
    impl<T> CommutativeMul for T where T: Number {}
    impl<T> IdentityMul for T
    where
        T: Number,
    {
        fn one() -> Self {
            <T as Number>::ONE
        }
    }
    impl<T> AssociativeMul for T where T: Number {}
    impl<T> LowerBound for T
    where
        T: Number,
    {
        fn min_element() -> Self {
            <T as Number>::MIN
        }
    }
    impl<T> UpperBound for T
    where
        T: Number,
    {
        fn max_element() -> Self {
            <T as Number>::MAX
        }
    }

    #[derive(Clone, Copy, Debug)]
    pub struct Nil;
    impl Mul for Nil {
        type Output = Nil;

        fn mul(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }
    impl Add for Nil {
        type Output = Nil;

        fn add(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }
    impl Sub for Nil {
        type Output = Nil;

        fn sub(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }

    impl Div for Nil {
        type Output = Nil;

        fn div(self, rhs: Nil) -> Self::Output {
            Nil
        }
    }
    impl PartialEq for Nil {
        fn eq(&self, other: &Self) -> bool {
            true
        }
    }
    impl Eq for Nil {}
    impl PartialOrd for Nil {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            Some(std::cmp::Ordering::Equal)
        }
    }
    impl LowerBound for Nil {
        fn min_element() -> Self {
            Nil
        }
    }
    impl UpperBound for Nil {
        fn max_element() -> Self {
            Nil
        }
    }
    AllGenerator!(Nil, Nil, Nil);
    pub(crate) use AddGenerator;
    pub(crate) use AllGenerator;
    pub(crate) use LiteAddGenerator;
    pub(crate) use LiteMulGenerator;
    pub(crate) use MulGenerator;
}
pub mod algebraic_structure {
    use crate::arithmetic::*;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;

    pub trait Magma: Add<Output = Self> + Copy + Eq {}
    impl<T> Magma for T where T: Add<Output = Self> + Copy + Eq {}
    pub trait Semigroup: Magma + AssociativeAdd {}
    impl<T> Semigroup for T where T: Magma + AssociativeAdd {}
    pub trait Monoid: Semigroup + IdentityAdd {}
    impl<T> Monoid for T where T: Semigroup + IdentityAdd {}
    pub trait Group: Monoid + Sub<Output = Self> {}
    impl<T> Group for T where T: Monoid + Sub<Output = Self> {}
    pub trait AbelianGroup: Group + CommutativeAdd {}
    impl<T> AbelianGroup for T where T: Group + CommutativeAdd {}
    pub trait Ring: AbelianGroup + Mul<Output = Self> + IdentityMul {}
    impl<T> Ring for T where T: AbelianGroup + Mul<Output = Self> + IdentityMul {}
    pub trait CommutativeRing: Ring + CommutativeMul {}
    impl<T> CommutativeRing for T where T: Ring + CommutativeMul {}
    pub trait IntegralDomain: CommutativeRing + IntegralMul {}
    impl<T> IntegralDomain for T where T: CommutativeRing + IntegralMul {}
    pub trait Field: IntegralDomain + Div<Output = Self> {}
    impl<T> Field for T where T: IntegralDomain + Div<Output = Self> {}
}
pub mod segment {
    use std::collections::HashMap;
    macro_rules! have_intersection {
        ($l: expr, $r: expr, $L: expr, $R: expr) => {
            (($l) <= ($R) && ($r) >= ($L))
        };
    }

    macro_rules! cover {
        ($l: expr, $r: expr, $L: expr, $R: expr) => {
            (($l) <= ($L) && ($R) <= ($r))
        };
    }

    pub fn estimate_tree_size_with_cache(n: usize, cache: &mut HashMap<usize, usize>) -> usize {
        if n <= 1 {
            return n;
        }
        match cache.get(&n) {
            Some(k) => *k,
            None => {
                let res = 1
                    + estimate_tree_size_with_cache(n >> 1, cache)
                    + estimate_tree_size_with_cache((n + 1) >> 1, cache);
                cache.insert(n, res);
                res
            }
        }
    }
    pub fn estimate_tree_size(n: usize) -> usize {
        let mut map = HashMap::new();
        estimate_tree_size_with_cache(n, &mut map)
    }
    pub(crate) use cover;
    pub(crate) use have_intersection;
}
pub mod segtree {
    use crate::segment::cover;
    use crate::segment::estimate_tree_size;
    use crate::segment::have_intersection;
    use crate::template_macro::should_eq;
    use std::fmt::Debug;
    use std::marker::PhantomData;
    use std::ops::Add;

    #[derive(Clone, Copy, Debug)]
    struct NodeRow<S: Copy + Debug, U: Copy + Debug + Eq> {
        right: usize,
        sum: S,
        update: U,
    }

    const ROOT: usize = 0;
    pub struct Segtree<S: Copy + Debug + Add<S> + Add<U, Output = S>, U: Copy + Debug + Eq + Add<U>> {
        nodes: Vec<NodeRow<S, U>>,
        L: usize,
        R: usize,
        nil_sum: S,
        nil_update: U,
    }
    impl<S: Copy + Debug + Add<S> + Add<U, Output = S>, U: Copy + Debug + Eq + Add<U>> Debug
        for Segtree<S, U>
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("Segtree")
                .field("nodes", &self.nodes)
                .field("L", &self.L)
                .field("R", &self.R)
                .field("zero_T", &self.nil_sum)
                .field("zero_U", &self.nil_update)
                .finish()
        }
    }
    impl<
            S: Copy + Debug + Add<S, Output = S> + Add<U, Output = S>,
            U: Copy + Debug + Eq + Add<U, Output = U>,
        > Segtree<S, U>
    {
        fn push_up(&mut self, root: usize) {
            self.nodes[root].sum =
                self.nodes[root + 1].sum + self.nodes[self.nodes[root].right].sum;
        }
        fn modify(&mut self, root: usize, upd: U) {
            self.nodes[root].sum = self.nodes[root].sum + upd;
            self.nodes[root].update = self.nodes[root].update + upd;
        }
        fn push_down(&mut self, root: usize) {
            if self.nodes[root].update != self.nil_update {
                let u = self.nodes[root].update;
                self.modify(root + 1, u);
                self.modify(self.nodes[root].right, u);
                self.nodes[root].update = self.nil_update;
            }
        }

        pub fn new(L: usize, R: usize, f: impl Fn(usize) -> S, nil_sum: S, nil_update: U) -> Self {
            let capacity = estimate_tree_size(R - L + 1);
            let mut res = Self {
                nodes: Vec::with_capacity(capacity),
                L,
                R,
                nil_sum,
                nil_update,
            };
            res.initialize(L, R, &f);
            should_eq!(res.nodes.len(), capacity);
            res
        }

        fn initialize(&mut self, l: usize, r: usize, f: &impl Fn(usize) -> S) -> usize {
            let root = self.nodes.len();
            self.nodes.push(NodeRow {
                right: usize::MAX,
                sum: self.nil_sum,
                update: self.nil_update,
            });
            if l == r {
                self.nodes[root].sum = f(l);
                return root;
            }
            let m = (l + r) >> 1;
            self.initialize(l, m, f);
            self.nodes[root].right = self.initialize(m + 1, r, f);
            self.push_up(root);
            root
        }
        pub fn update(&mut self, l: usize, r: usize, u: U) {
            self.update_rec(ROOT, l, r, self.L, self.R, u)
        }

        pub fn query(&mut self, l: usize, r: usize) -> S {
            self.query_rec(ROOT, l, r, self.L, self.R)
        }
        fn update_rec(&mut self, root: usize, L: usize, R: usize, l: usize, r: usize, u: U) {
            if !have_intersection!(L, R, l, r) {
                return;
            }
            if cover!(L, R, l, r) {
                self.modify(root, u);
                return;
            }
            let m = (l + r) >> 1;
            self.push_down(root);
            self.update_rec(root + 1, L, R, l, m, u);
            self.update_rec(self.nodes[root].right, L, R, m + 1, r, u);
            self.push_up(root);
        }

        fn query_rec(&mut self, root: usize, L: usize, R: usize, l: usize, r: usize) -> S {
            if !have_intersection!(L, R, l, r) {
                return self.nil_sum;
            }
            if cover!(L, R, l, r) {
                return self.nodes[root].sum;
            }
            let m = (l + r) >> 1;
            self.push_down(root);
            let lson = self.query_rec(root + 1, L, R, l, m);
            let rson = self.query_rec(self.nodes[root].right, L, R, m + 1, r);
            lson + rson
        }
    }
}
pub mod range_affine_range_sum {
    use crate::algebraic_structure::CommutativeRing;
    use crate::segtree::Segtree;
    use crate::template_macro::AddImpl;
    use std::fmt::Debug;
    use std::ops::*;

    #[derive(Clone, Copy, Debug, PartialEq)]
    struct S<T: CommutativeRing>(T, T);
    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
    struct U<T: CommutativeRing>(T, T);
    impl<T: CommutativeRing> Add<S<T>> for S<T> {
        type Output = S<T>;

        fn add(self, y: S<T>) -> Self::Output {
            let x = self;
            S(x.0 + y.0, x.1 + y.1)
        }
    }
    impl<T: CommutativeRing> Add<U<T>> for S<T> {
        type Output = S<T>;

        fn add(self, y: U<T>) -> Self::Output {
            let x = self;
            S(y.0 * x.0 + x.1 * y.1, x.1)
        }
    }
    impl<T: CommutativeRing> Add<U<T>> for U<T> {
        type Output = U<T>;

        fn add(self, y: U<T>) -> Self::Output {
            let x = self;
            U(y.0 * x.0, y.1 + x.1 * y.0)
        }
    }
    pub struct RangeAffineRangeSum<T>
    where
        T: CommutativeRing,
    {
        st: Segtree<S<T>, U<T>>,
    }
    impl<T> Debug for RangeAffineRangeSum<T>
    where
        T: CommutativeRing,
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.st.fmt(f)
        }
    }

    impl<T> RangeAffineRangeSum<T>
    where
        T: CommutativeRing,
    {
        pub fn new(l: usize, r: usize, f: impl Fn(usize) -> T) -> Self {
            Self {
                st: Segtree::new(
                    l,
                    r,
                    |x| S(f(x), T::one()),
                    S(T::zero(), T::zero()),
                    U(T::one(), T::zero()),
                ),
            }
        }
        pub fn query(&mut self, l: usize, r: usize) -> T {
            self.st.query(l, r).0
        }

        pub fn update(&mut self, l: usize, r: usize, a: T, b: T) {
            self.st.update(l, r, U(a, b))
        }
    }
}
pub mod num_gcd {
    use crate::num_integer::Integer;
    use crate::template_macro::should;
    use crate::template_macro::should_eq;

    pub fn gcd<T>(a: T, b: T) -> T
    where
        T: Integer,
    {
        should! {a.is_non_negative(), b.is_non_negative()};
        let mut s = (a, b);
        while s.1 > T::ZERO {
            s = (s.1, s.0 % s.1);
        }
        s.0
    }

    pub fn extgcd<T>(a: T, b: T) -> (T, T, T)
    where
        T: Integer,
    {
        should!(a.is_non_negative(), b.is_non_negative());
        if b == T::ZERO {
            (T::ONE, T::ZERO, a)
        } else {
            let div_and_rem = T::div_and_remainder(a, b);
            let ans = extgcd(b, div_and_rem.1);
            (ans.1, ans.0 - div_and_rem.0 * ans.1, ans.2)
        }
    }

    pub fn inv_mod<T>(a: T, m: T) -> Option<T>
    where
        T: Integer,
    {
        let res = extgcd(a, m);
        if res.2 == T::ONE {
            Some(T::modular(res.0, m))
        } else {
            None
        }
    }
}
pub mod static_modint {
    use crate::algebraic_structure::*;
    use crate::arithmetic::*;
    use crate::num_gcd::inv_mod;
    use crate::num_integer::Integer;
    use crate::num_number::Number;
    use std::fmt;
    use std::fmt::Debug;
    use std::fmt::Display;
    use std::fmt::Error;
    use std::marker::PhantomData;
    use std::num::ParseIntError;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;
    use std::str::FromStr;
    use std::string::ParseError;

    pub trait StaticModulusFactory<T> {
        const M: T;
        const ZERO: T;
        const ONE: T;
        const ROOT: T;
    }

    macro_rules! StaticModulusFactoryImpl {
        ($name: ident, $T: ty, $M: expr, $R: expr) => {
            pub struct $name;
            impl StaticModulusFactory<$T> for $name {
                const M: $T = ($M) as $T;

                const ZERO: $T = <$T>::ZERO;

                const ONE: $T = <$T>::ONE % ($M) as $T;

                const ROOT: $T = ($R) as $T;
            }
        };
    }

    StaticModulusFactoryImpl!(MF998_244_353, u32, 998_244_353, 3);
    StaticModulusFactoryImpl!(MF1_000_000_007, u32, 1_000_000_007, 5);
    StaticModulusFactoryImpl!(MF1_000_000_009, u32, 1_000_000_009, 13);

    pub struct StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        v: T,
        phantom: PhantomData<F>,
    }

    impl<T, F> FromStr for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        type Err = ();
        #[inline(always)]
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if let Ok(x) = T::from_str(s) {
                Ok(Self::new(x))
            } else {
                Result::Err(())
            }
        }
    }

    impl<T, F> Clone for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        #[inline(always)]
        fn clone(&self) -> Self {
            Self {
                v: self.v.clone(),
                phantom: PhantomData,
            }
        }
    }

    impl<T, F> Copy for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
    }

    impl<T, F> PartialEq for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        #[inline(always)]
        fn eq(&self, other: &Self) -> bool {
            self.v == other.v
        }
    }

    impl<T, F> Eq for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
    }

    impl<T, F> StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        #[inline(always)]
        pub fn new(v: T) -> Self {
            Self {
                v,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub fn value(&self) -> T {
            self.v
        }
        #[inline(always)]
        pub fn possible_inv(&self) -> Option<StaticModInt<T, F>> {
            inv_mod(self.v, F::M).map(Self::new)
        }
    }

    impl<T, F> Display for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            Display::fmt(&self.v, f)
        }
    }
    impl<T, F> Debug for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            Debug::fmt(&self.v, f)
        }
    }

    impl<T, F> Div for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        type Output = Self;

        fn div(self, rhs: Self) -> Self::Output {
            self * rhs.possible_inv().unwrap()
        }
    }

    impl<T, F> Mul for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        type Output = Self;
        #[inline(always)]
        fn mul(self, rhs: Self) -> Self::Output {
            Self::new(T::mul_mod(self.v, rhs.v, F::M))
        }
    }

    impl<T, F> Sub for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        type Output = Self;
        #[inline(always)]
        fn sub(self, rhs: Self) -> Self::Output {
            Self::new(if self.v >= rhs.v {
                self.v - rhs.v
            } else {
                self.v - rhs.v + F::M
            })
        }
    }

    impl<T, F> Add for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        type Output = Self;
        #[inline(always)]
        fn add(self, rhs: Self) -> Self::Output {
            Self::new({
                let res = self.v + rhs.v;
                if res < self.v || res >= F::M {
                    res - F::M
                } else {
                    res
                }
            })
        }
    }

    impl<T, F> StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        #[inline(always)]
        fn mul_inv(&self) -> Self {
            self.possible_inv().unwrap()
        }
    }

    impl<T, F> CommutativeAdd for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
    }

    impl<T, F> AssociativeAdd for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
    }

    impl<T, F> IdentityAdd for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        #[inline(always)]
        fn zero() -> Self {
            Self::new(F::ZERO)
        }
    }

    impl<T, F> CommutativeMul for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
    }

    impl<T, F> AssociativeMul for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
    }

    impl<T, F> IdentityMul for StaticModInt<T, F>
    where
        T: 'static + Integer,
        F: StaticModulusFactory<T>,
    {
        #[inline(always)]
        fn one() -> Self {
            Self::new(F::ONE)
        }
    }
    pub(crate) use StaticModulusFactoryImpl;
}
pub mod contest_macro {

    #[cfg(feature = "local-build")]
    macro_rules! should {
    ($($e: expr),*) => {
        $(
            assert!($e);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! should_eq {
    ($($a: expr, $b: expr);*) => {
        $(
            assert_eq!($a, $b);
        )*
    }
}

    #[cfg(not(feature = "local-build"))]
    macro_rules! should_eq {
        ($($e: expr),*) => {};
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug {
        ($e: expr) => {
            std::convert::identity($e)
        };
    }

    #[cfg(feature = "local-build")]
    macro_rules! debug_discard {
        ($e: expr) => {
            dbg!($e)
        };
    }

    #[cfg(not(feature = "local-build"))]
    macro_rules! debug_discard {
        ($e: expr) => {};
    }

    macro_rules! input {
    ($fi:ident, $($var:ident$( : $t:ty)?),*) => {
        $(
            let mut $var $(: $t)? = $fi.read();
        )*
    };
}

    macro_rules! MergerImpl {
        ($name: ident, $A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            struct $name;
            impl Merger<$A, $B, $C> for $name {
                fn merge($a: $A, $b: $B) -> $C {
                    $body
                }
            }
        };
    }
    macro_rules! AddImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Add<$B> for $A {
                type Output = $C;

                fn add(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }
    macro_rules! SubImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Mul<$B> for $A {
                type Output = $C;

                fn sub(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }
    macro_rules! DivImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Mul<$B> for $A {
                type Output = $C;

                fn div(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }
    macro_rules! MulImpl {
        ($A: ty, $B: ty, $C: ty, $a: ident, $b: ident, $body: tt) => {
            impl Sub<$B> for $A {
                type Output = $C;

                fn mul(self, $b: $B) -> Self::Output {
                    let $a = self;
                    $body
                }
            }
        };
    }

    pub(crate) use debug;
    pub(crate) use debug_discard;
    pub(crate) use input;
    pub(crate) use should;
    pub(crate) use should_eq;
    pub(crate) use AddImpl;
    pub(crate) use DivImpl;
    pub(crate) use MergerImpl;
    pub(crate) use MulImpl;
    pub(crate) use SubImpl;
}
pub mod solver {
    use crate::contest_macro::input;
    use crate::fast_input::FastInput;
    use crate::range_affine_range_sum::RangeAffineRangeSum;
    use crate::static_modint::StaticModInt;
    use crate::static_modint::MF998_244_353;
    use std::io::BufRead;
    use std::io::Write;
    use std::ops::Add;
    use std::ops::Div;
    use std::ops::Mul;
    use std::ops::Sub;
    use std::panic;

    type mi = StaticModInt<u32, MF998_244_353>;

    pub unsafe fn solve_one<I: BufRead>(test_id: u32, fi: &mut FastInput<I>, fo: &mut impl Write) {
        let n = fi.ru();
        let q = fi.ru();
        let mut data = Vec::with_capacity(n);
        for _ in 0..n {
            data.push(mi::new(fi.read()));
        }
        let mut rars = RangeAffineRangeSum::new(0, n - 1, &|x| data[x]);
        for i in 0..q {
            let t = fi.ri();
            let l = fi.ru();
            let r = fi.ru() - 1;
            if t == 0 {
                rars.update(l, r, mi::new(fi.read()), mi::new(fi.read()));
            } else {
                let sum = rars.query(l, r);
                writeln!(fo, "{}", sum);
            }
        }
    }
    pub unsafe fn solve_multi<I: BufRead>(fi: &mut FastInput<I>, fo: &mut impl Write) {
        let t: u32 = 1;
        for test_id in 1..t + 1 {
            solve_one(test_id, fi, fo);
        }
    }
}
pub mod rand {
    struct xorshift128p_state(u64, u64);

    #[cfg(feature = "local-build")]
    fn seed() -> u64 {
        dbg!("use fix seed 0");
        0
    }

    #[cfg(not(feature = "local-build"))]
    fn seed() -> u64 {
        let start = std::time::SystemTime::now();
        start
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }

    fn splitmix64(state: &mut u64) -> u64 {
        *state += 0x9E3779B97f4A7C15;
        let mut result = *state;
        result = (result ^ (result >> 30)) * 0xBF58476D1CE4E5B9;
        result = (result ^ (result >> 27)) * 0x94D049BB133111EB;
        return result ^ (result >> 31);
    }

    fn xorshift128p_init(seed: u64) -> xorshift128p_state {
        let mut smstate = seed;
        let mut result = xorshift128p_state(0, 0);

        result.0 = splitmix64(&mut smstate);
        result.1 = splitmix64(&mut smstate);

        result
    }

    fn xorshift128p(state: &mut xorshift128p_state) -> u64 {
        let mut t = state.0;
        let s = state.1;
        state.0 = s;
        t ^= t << 32;
        t ^= t >> 18;
        t ^= s ^ (s >> 5);
        state.1 = t;
        t + s
    }

    pub fn rng() -> &'static mut Rng {
        static mut singleton: Option<Rng> = None;
        unsafe {
            match &mut singleton {
                Some(x) => x,
                None => {
                    singleton = Some(Rng::new());
                    rng()
                }
            }
        }
    }

    pub struct Rng {
        state: xorshift128p_state,
    }

    impl Rng {
        pub fn new() -> Self {
            Self {
                state: xorshift128p_init(seed()),
            }
        }
        pub fn init(&mut self, seed: u64) {
            self.state = xorshift128p_init(seed);
        }
        pub fn new_with_seed(seed: u64) -> Self {
            Self {
                state: xorshift128p_init(seed),
            }
        }

        pub fn u64(&mut self) -> u64 {
            xorshift128p(&mut self.state)
        }
        pub fn usize(&mut self) -> usize {
            self.u64() as usize
        }
        pub fn f64(&mut self) -> f64 {
            loop {
                let res = self.u64();
                if res < u64::MAX {
                    return res as f64 / usize::MAX as f64;
                }
            }
        }
        pub fn limit_usize(&mut self, n: usize) -> usize {
            self.limit_u64(n as u64) as usize
        }
        pub fn limit_u64(&mut self, n: u64) -> u64 {
            (self.f64() * n as f64) as u64
        }
        pub fn range_u64(&mut self, l: u64, r: u64) -> u64 {
            let n = r - l + 1;
            self.limit_u64(r - l + 1) + l
        }
        pub fn range_usize(&mut self, l: usize, r: usize) -> usize {
            self.range_u64(l as u64, r as u64) as usize
        }
    }
}
pub mod stress_external_member {
    use crate::fast_input::FastInput;
    use crate::rand::Rng;
    use std::io::BufRead;
    use std::io::Write;
    use std::mem::swap;

    pub unsafe fn brute_force<InT>(fi: &mut FastInput<InT>, fo: &mut impl Write)
    where
        InT: BufRead,
    {
    }

    pub fn generate_test(rng: &mut Rng, fo: &mut impl Write) {}

    pub fn against(a: &String, b: &String) -> bool {
        let da: Vec<_> = a.split_ascii_whitespace().collect();
        let db: Vec<_> = b.split_ascii_whitespace().collect();
        da == db
    }
}
pub mod stress {
    use crate::fast_input::FastInput;
    use crate::rand::rng;
    use crate::rand::Rng;
    use crate::solver::solve_multi;
    use crate::stress_external_member::against;
    use crate::stress_external_member::brute_force;
    use crate::stress_external_member::generate_test;
    use std::fmt::Display;
    use std::io::BufReader;
    use std::io::Cursor;
    use std::io::Write;

    fn printable_input(s: String) -> String {
        let len = 1000;
        if s.len() < len {
            s
        } else {
            s[0..len].to_string() + "..."
        }
    }

    pub unsafe fn stress() {
        let mut round = 0;
        let mut rng_for_input_generator = Rng::new_with_seed(0);
        loop {
            round += 1;
            if round >= 10000 {
                println!("Pass stress!");
                return;
            }
            rng().init(0);

            let mut input = OutputWrapper::new();
            generate_test(&mut rng_for_input_generator, &mut input);
            println!("Test {}:", round);
            println!("{}\n", printable_input(input.to_string()));
            let mut actual_output = OutputWrapper::new();
            let mut expect_output = OutputWrapper::new();
            solve_multi(
                &mut FastInput::new(BufReader::new(Cursor::new(input.to_string()))),
                &mut actual_output,
            );
            brute_force(
                &mut FastInput::new(BufReader::new(Cursor::new(input.to_string()))),
                &mut expect_output,
            );
            if !against(&actual_output.to_string(), &expect_output.to_string()) {
                println!("Test case {}:", round);
                println!("\nInput:\n{}", input);
                println!("\nExpect:\n{}", expect_output);
                println!("\nActual:\n{}", actual_output);
                panic!("Fail!");
            }
        }
    }
    struct OutputWrapper(Vec<u8>);
    impl OutputWrapper {
        pub fn new() -> OutputWrapper {
            OutputWrapper(Vec::new())
        }
    }
    impl Display for OutputWrapper {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = String::from_utf8(self.0.clone()).unwrap();
            f.write_str(s.as_str())
        }
    }
    impl Write for OutputWrapper {
        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
            let mut to = buf.iter().map(|x| *x).collect();
            self.0.append(&mut to);
            Ok(buf.len())
        }

        fn flush(&mut self) -> std::io::Result<()> {
            Ok(())
        }
    }
}
use crate::fast_input::FastInput;
use crate::solver::solve_multi;
use crate::stress::stress;
use std::io::BufWriter;
use std::thread;

#[allow(dead_code)]
unsafe fn run_in_current_thread() {
    let stdin = std::io::stdin();
    let stdout = std::io::stdout();
    let mut fi = FastInput::new(stdin.lock());
    let mut fo = BufWriter::new(stdout.lock());
    solve_multi(&mut fi, &mut fo);
}

#[allow(dead_code)]
unsafe fn run_in_new_thread() {
    thread::Builder::new()
        .stack_size(256 << 20)
        .spawn(|| {
            run_in_current_thread();
        })
        .unwrap()
        .join();
}
#[cfg(not(feature = "stress"))]
fn main() {
    unsafe {
        run_in_current_thread();
    }
}

#[cfg(feature = "stress")]
fn main() {
    unsafe {
        stress();
    }
}
